### 1.为什么redis单线程还那么快？
第一次看到这个问题我整个人都傻了，单线程为什么就不能充分调动资源？多线程一定比单线程快？
主要原因有两个：
- 因为它所有的数据都在内存中，所有的运算都是内存级别的运算（纳秒）。
- 单线程避免了多线程的切换（上下文切换）性能损耗问题。
-  Redis 利用了多路I/0复用机制处理客户端请求，不会阻塞线程

深入进去，这跟[C10K问题](https://www.jianshu.com/p/ba7fa25d3590)有关，linux使用了epoll来解决这个问题，这也正是redis采用的解决方案，所以redis能用同一个线程/进程同时处理多个连接（**I/O多路复用**）。

### 2.Redis 与 MQ 的区别
Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。可以使用它来做消息队列用。
- redis： 轻量级，低延迟，高并发，低可靠性；
- rabbitmq：重量级，高可靠，异步，不保证实时；
- rabbitmq是一个专门的AMQP协议队列，他的优势就在于提供可靠的队列服务，并且可做到异步，而redis主要是用于缓存的，redis的发布订阅模块，可用于实现及时性，且可靠性低的功能。

参见 [Redis 与 MQ 的区别](https://www.cnblogs.com/dengguangxue/p/11537466.html)

### 3.Redis 三大缓存问题
- 缓存穿透：指缓存在查询redis不存在相应的值之后每次都去查询数据库，这样一个永远不存在的值会被人利用作为攻击手段。可以通过**布隆过滤器**或者将**空值缓存起来**设置短时间的方法解决。
- 缓存雪崩：某部分热点缓存设定了同样的过期时间，在一瞬间全部过期，造成大量请求涌入数据库，造成崩溃。可以通过**设置不同的时间间隔**（随机时间也可）或者永不过期来避免这种情况发生。如果是redis集群，这些热点数据可以单独存放，设为永不过期。
- 缓存击穿：指某个热点数据访问量非常大，过期的那一瞬间将数据库击溃。需要提前预知，将这类数据**设定为永不过期**。

### 4.Redis如何优化使用
#### 网络瓶颈
- 使用unix进程间通信，如果单机部署
- 使用multi-key指令合并多个指令,减少请求数,如果有可能的话
- 使用transaction、script 合并requests以及responses
- 使用pipeline合并response
#### 内存瓶颈
- 尽量不要缓存JSON大对象
- 合理设置过期时间，节省资源
- 设置集群
- 使用合理的持久化策略
#### CPU瓶颈
- 禁止耗时的指令，如 [KEYS *]
- 删除大对象内存使用异步命令[UNLINK]，而不用[DEL]

### 5.Redis的基础数据类型和应用场景
#### String
键都是字符串类型，用于缓存信息
#### Hash
哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车
![购物车](https://upload-images.jianshu.io/upload_images/14359229-1a0de4f097fcbbdb.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp)
[Redis-hash类型数据实现购物车](https://www.jianshu.com/p/a00801ea872f)
[天猫Java研发三面：讲讲Redis实现购物车的设计思路！](https://www.codenong.com/js0f5df2973d1c/)
#### List
列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能
#### Set
集合（set）类型也是用来保存多个的字符串元素，不能有重复，不能通过下标取值，利用Set的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
#### Sorted Set
Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。