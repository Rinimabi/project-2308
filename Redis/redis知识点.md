## 1.为什么redis单线程还那么快？
第一次看到这个问题我整个人都傻了，单线程为什么就不能充分调动资源？多线程一定比单线程快？
主要原因有两个：
- 因为它所有的数据都在内存中，所有的运算都是内存级别的运算（纳秒）。
- 单线程避免了多线程的切换（上下文切换）性能损耗问题。

深入进去，这跟[C10K问题](https://www.jianshu.com/p/ba7fa25d3590)有关，linux使用了epoll来解决这个问题，这也正是redis采用的解决方案，所以redis能用同一个线程/进程同时处理多个连接（**I/O多路复用**）。

## 2.Redis 与 MQ 的区别
Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。可以使用它来做消息队列用。
- redis： 轻量级，低延迟，高并发，低可靠性；
- rabbitmq：重量级，高可靠，异步，不保证实时；
- rabbitmq是一个专门的AMQP协议队列，他的优势就在于提供可靠的队列服务，并且可做到异步，而redis主要是用于缓存的，redis的发布订阅模块，可用于实现及时性，且可靠性低的功能。

参见 [Redis 与 MQ 的区别](https://www.cnblogs.com/dengguangxue/p/11537466.html)

## 3.Redis 三大缓存问题
- 缓存穿透：指缓存在查询redis不存在相应的值之后每次都去查询数据库，这样一个永远不存在的值会被人利用作为攻击手段。可以通过**布隆过滤器**或者将**空值缓存起来**设置短时间的方法解决。
- 缓存雪崩：某部分热点缓存设定了同样的过期时间，在一瞬间全部过期，造成大量请求涌入数据库，造成崩溃。可以通过**设置不同的时间间隔**（随机时间也可）或者永不过期来避免这种情况发生。如果是redis集群，这些热点数据可以单独存放，设为永不过期。
- 缓存击穿：指某个热点数据访问量非常大，过期的那一瞬间将数据库击溃。需要提前预知，将这类数据**设定为永不过期**。